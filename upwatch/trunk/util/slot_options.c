/*   -*- buffer-read-only: t -*- vi: set ro:
 *  
 *  DO NOT EDIT THIS FILE   (slot_options.c)
 *  
 *  It has been AutoGen-ed  Thursday May 20, 2004 at 05:45:10 PM CEST
 *  From the definitions    slot_options.def
 *  and the template file   options
 */
#include <stdio.h>
#include <limits.h>
#include "slot_options.h"

#ifdef  __cplusplus
extern "C" {
#endif
tSCC zCopyright[] =
       "slot copyright (c) 2002 Upwatch BV, all rights reserved";
tSCC zCopyrightNotice[] =
       "Redistribution Prohibited. Violation will be prosecuted to the maximum extent possible by applicable law.";
extern tOptProc doVersionStderr, doVersion, doPagedUsage;
static tOptProc doUsageOpt,   doOptVerbose;
extern tUsageProc optionUsage;

#ifndef NULL
#  define NULL 0
#endif
#ifndef EXIT_SUCCESS
#  define  EXIT_SUCCESS 0
#endif
#ifndef EXIT_FAILURE
#  define  EXIT_FAILURE 1
#endif
/*
 *  Verbose option description:
 */
tSCC    zVerboseText[] =
        "Verbose mode";
tSCC    zVerbose_NAME[]            = "VERBOSE";
#define zNotVerbose_Pfx              NULL
#define zNotVerbose_Name             NULL
tSCC    zVerbose_Name[]            = "verbose";
#define zVerboseDefaultArg           ((tCC*)0)
#define VERBOSE_FLAGS       (OPTST_NUMERIC | OPTST_DISABLED)

/*
 *  Help option description:
 */
tSCC zHelpText[]  = "Display usage information and exit";
tSCC zHelp_Name[] = "help";

/*
 *  More_Help option description:
 */
tSCC zMore_HelpText[]  = "Extended usage information passed thru pager";
tSCC zMore_Help_Name[] = "more-help";

/*
 *  Version option description:
 */
tSCC zVersionText[]    = "Output version information and exit";
tSCC zVersion_Name[]   = "version";

#define DOVERPROC doVersion

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Define the Slot Option Descriptions.
 */
static tOptDesc optDesc[ OPTION_CT ] = {
  {  /* entry idx, value */ 0, VALUE_OPT_VERBOSE,
     /* equiv idx, value */ 0, VALUE_OPT_VERBOSE,
     /* option argument  */ ARG_MUST,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ VERBOSE_FLAGS,
     /* last opt argumnt */ (char*)zVerboseDefaultArg,
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptVerbose,
     /* desc, NAME, name */ zVerboseText,  zVerbose_NAME,
                            zVerbose_Name,
     /* disablement strs */ zNotVerbose_Name, zNotVerbose_Pfx },

  {  /* entry idx, value */ INDEX_OPT_VERSION, VALUE_OPT_VERSION,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* option argument  */ ARG_MAY,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max act ct  */ 0, 1, 0,
     /* opt state flags  */ OPTST_INIT,
     /* last opt argumnt */ NULL,
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ DOVERPROC,
     /* desc, NAME, name */ zVersionText, NULL, zVersion_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_HELP, VALUE_OPT_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* option argument  */ ARG_NONE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max act ct  */ 0, 1, 0,
     /* opt state flags  */ OPTST_IMM,
     /* last opt argumnt */ NULL,
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doUsageOpt,
     /* desc, NAME, name */ zHelpText, NULL, zHelp_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_MORE_HELP, VALUE_OPT_MORE_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* option argument  */ ARG_NONE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max act ct  */ 0, 1, 0,
     /* opt state flags  */ OPTST_IMM,
     /* last opt argumnt */ NULL,
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ doPagedUsage,
     /* desc, NAME, name */ zMore_HelpText, NULL, zMore_Help_Name,
     /* disablement strs */ NULL, NULL }
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Define the Slot Option Environment
 */
tSCC   zPROGNAME[]   = "SLOT";
tSCC   zUsageTitle[] =
"slot - prints out slotnumbers for given time values - Ver. 0.95\n\
USAGE:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [string]\n";
#define zRcName     NULL
#define apzHomeList NULL

tSCC   zBugsAddr[]    = "info@upwatch.com";
tSCC   zExplain[]     = "\n\n";
tSCC    zDetail[]     = "\n\
Upwatch keeps statistics by day, by week, by month, year and 5 year\n\
periods. Each period is divided in 100 `slots`. This utility prints\n\
slotnumbers, given a ctime argument\n";
tSCC    zFullVersion[] = SLOT_FULL_VERSION;

tOptions slotOptions = {
    OPTIONS_STRUCT_VERSION,
    NULL,           NULL,           zPROGNAME,
    zRcName,        zCopyright,     zCopyrightNotice,
    zFullVersion,   apzHomeList,    zUsageTitle,
    zExplain,       zDetail,        NULL,           optionUsage,
    ( OPTPROC_NONE
    + OPTPROC_ERRSTOP
    + OPTPROC_SHORTOPT
    + OPTPROC_LONGOPT
    + OPTPROC_NO_REQ_OPT ),
    0, NULL,
    { INDEX_OPT_MORE_HELP,
       0 /* no option state saving */,
      NO_EQUIVALENT /* no '-#' option */,
      NO_EQUIVALENT /* no default option */ },
    OPTION_CT, 1 /* user option count */,
    optDesc,
    0, (char**)NULL,  /* original argc + argv    */
    zBugsAddr         /* address to send bugs to */
};

/*
 *  Create the static procedure(s) declared above.
 */
static void
doUsageOpt(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    USAGE( EXIT_SUCCESS );
}

/* * * * * * *
 *
 *   For the "Verbose Option".
 */
static void
doOptVerbose(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    static const struct {const int rmin, rmax;} rng[ 1 ] = {
        { 0, 9 } };
    int val, ix;
    tCC* pzIndent = "\t\t\t\t  ";
    extern FILE* option_usage_fp;

    if (pOptDesc == NULL) /* usage is requesting range list
                             option_usage_fp has already been set */
        goto emit_ranges;

    val = atoi( pOptDesc->pzLastArg );
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == INT_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

    option_usage_fp = stderr;
    fprintf( stderr, "%s error:  %s option value ``%s''is out of range.\n",
             pOptions->pzProgName, pOptDesc->pz_Name, pOptDesc->pzLastArg );
    pzIndent = "\t";

  emit_ranges:
    fprintf( option_usage_fp, "%sit must lie in the range: %d to %d\n",
             pzIndent, rng[0].rmin, rng[0].rmax );
    if (pOptDesc == NULL)
        return;

    USAGE( EXIT_FAILURE );
    /* NOTREACHED */
    return;

  valid_return:
    pOptDesc->pzLastArg = (char*)val;
}

#ifdef  __cplusplus
}
#endif
