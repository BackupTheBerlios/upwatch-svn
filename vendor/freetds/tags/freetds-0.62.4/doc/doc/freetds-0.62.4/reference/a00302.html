<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Charset conversion</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><h1>Charset conversion<br>
<small>
[<a class="el" href="a00311.html">LibTDS API</a>]</small>
</h1>Convert between different charsets. 
<a href="#_details">More...</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td nowrap align=right valign=top><a name="a21" doxytag="conv::CHUNK_ALLOC"></a>
#define&nbsp;</td><td valign=bottom><b>CHUNK_ALLOC</b>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>iconv_t&nbsp;</td><td valign=bottom><a class="el" href="a00302.html#a0">tds_rep_iconv_open</a> (const char *tocode, const char *fromcode)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Inputs are FreeTDS canonical names, no other.</em> <a href="#a0"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a1" doxytag="conv::tds_rep_iconv_close"></a>
int&nbsp;</td><td valign=bottom><b>tds_rep_iconv_close</b> (iconv_t cd)</td></tr>
<tr><td nowrap align=right valign=top><a name="a2" doxytag="conv::tds_rep_iconv"></a>
size_t&nbsp;</td><td valign=bottom><b>tds_rep_iconv</b> (iconv_t cd, const char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft)</td></tr>
<tr><td nowrap align=right valign=top><a name="a3" doxytag="conv::tds_iconv_open"></a>
void&nbsp;</td><td valign=bottom><b>tds_iconv_open</b> (TDSSOCKET *tds, const char *charset)</td></tr>
<tr><td nowrap align=right valign=top><a name="a7" doxytag="conv::tds_iconv_close"></a>
void&nbsp;</td><td valign=bottom><b>tds_iconv_close</b> (TDSSOCKET *tds)</td></tr>
<tr><td nowrap align=right valign=top><a name="a8" doxytag="conv::tds_iconv_free"></a>
void&nbsp;</td><td valign=bottom><b>tds_iconv_free</b> (TDSSOCKET *tds)</td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="a00302.html#a9">tds_iconv</a> (TDSSOCKET *tds, const TDSICONVINFO *iconv_info, TDS_ICONV_DIRECTION io, const char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Wrapper around iconv(3).</em> <a href="#a9"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="a00302.html#a10">tds_iconv_fread</a> (iconv_t cd, FILE *stream, size_t field_len, size_t term_len, char *outbuf, size_t *outbytesleft)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Read a data file, passing the data through <a class="el" href="a00279.html#a2">iconv()</a>.</em> <a href="#a10"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a12" doxytag="conv::tds_srv_charset_changed"></a>
void&nbsp;</td><td valign=bottom><b>tds_srv_charset_changed</b> (TDSSOCKET *tds, const char *charset)</td></tr>
<tr><td nowrap align=right valign=top><a name="a13" doxytag="conv::tds7_srv_charset_changed"></a>
void&nbsp;</td><td valign=bottom><b>tds7_srv_charset_changed</b> (TDSSOCKET *tds, int lcid)</td></tr>
<tr><td nowrap align=right valign=top>const char *&nbsp;</td><td valign=bottom><a class="el" href="a00302.html#a17">tds_canonical_charset_name</a> (const char *charset_name)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Determine canonical iconv character set name.</em> <a href="#a17"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>const char *&nbsp;</td><td valign=bottom><a class="el" href="a00302.html#a18">tds_sybase_charset_name</a> (const char *charset_name)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Determine the name Sybase uses for a character set, given a canonical iconv name.</em> <a href="#a18"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a20" doxytag="conv::tds_iconv_from_lcid"></a>
TDSICONVINFO *&nbsp;</td><td valign=bottom><a class="el" href="a00302.html#a20">tds_iconv_from_lcid</a> (TDSSOCKET *tds, int lcid)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Get iconv information from a LCID (to support different column encoding under MSSQL2K).</em><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Convert between different charsets.
<p>
Set up the initial iconv conversion descriptors. When the socket is allocated, three TDSICONVINFO structures are attached to iconv_info. They have fixed meanings: <ul>
<li>0. Client &lt;-&gt; UCS-2 (client2ucs2) </li>
<li>1. Client &lt;-&gt; server single-byte charset (client2server_chardata) </li>
<li>2. ISO8859-1 &lt;-&gt; server meta data (iso2server_metadata)</li>
</ul>
Other designs that use less data are possible, but these three conversion needs are very often needed. By reserving them, we avoid searching the array for our most common purposes.<p>
To solve different iconv names and portability problem FreeTDS use a complex method. It maintain a list of all alias of a given charset. First it discover some needed charset (UTF-8, ISO8859-1 and UCS2) and then try to discover others from those characters (this discover happen only when required).<p>
There are a list of canonic names (GNU iconv names) and a set of aliases (one for others iconv implementations and another for Sybase). For every canonic charset name we cache iconv name found during discovery. <hr><h2>Function Documentation</h2>
<a name="a17" doxytag="tds/iconv.c::tds_canonical_charset_name"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const char* tds_canonical_charset_name </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>charset_name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determine canonical iconv character set name.
<p>
<dl compact><dt><b>Returns:</b></dt><dd>canonical name, or NULL if lookup failed. </dd></dl>
<dl compact><dt><b>Remarks:</b></dt><dd>Returned name can be used in bytes_per_char(), above. </dd></dl>
    </td>
  </tr>
</table>
<a name="a9" doxytag="tds/iconv.c::tds_iconv"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> size_t tds_iconv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">TDSSOCKET *&nbsp;</td>
          <td class="mdname" nowrap> <em>tds</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const TDSICONVINFO *&nbsp;</td>
          <td class="mdname" nowrap> <em>iconv_info</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>TDS_ICONV_DIRECTION&nbsp;</td>
          <td class="mdname" nowrap> <em>io</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char **&nbsp;</td>
          <td class="mdname" nowrap> <em>inbuf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>inbytesleft</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char **&nbsp;</td>
          <td class="mdname" nowrap> <em>outbuf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>outbytesleft</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Wrapper around iconv(3).
<p>
Same parameters, with slightly different behavior. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>io</em>&nbsp;</td><td>Enumerated value indicating whether the data are being sent to or received from the server. </td></tr>
    <tr><td valign=top><em>iconv_info</em>&nbsp;</td><td>information about the encodings involved, including the iconv(3) conversion descriptors. </td></tr>
    <tr><td valign=top><em>inbuf</em>&nbsp;</td><td>address of pointer to the input buffer of data to be converted. </td></tr>
    <tr><td valign=top><em>inbytesleft</em>&nbsp;</td><td>address of count of bytes in <em>inbuf</em>. </td></tr>
    <tr><td valign=top><em>outbuf</em>&nbsp;</td><td>address of pointer to the output buffer. </td></tr>
    <tr><td valign=top><em>outbytesleft</em>&nbsp;</td><td>address of count of bytes in <em>outbuf</em>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>number</em>&nbsp;</td><td>of irreversible conversions performed.  -1 on error, see iconv(3) documentation for a description of the possible values of  errno. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Remarks:</b></dt><dd>Unlike iconv(3), none of the arguments can be nor point to NULL. Like iconv(3), all pointers will be updated. Succcess is signified by a nonnegative return code and <em>*inbytesleft</em> == 0. If the conversion descriptor in <em>iconv_info</em> is -1 or NULL, <em>inbuf</em> is copied to <em>outbuf</em>, and all parameters updated accordingly.</dd></dl>
In the event that a character in <em>inbuf</em> cannot be converted because no such cbaracter exists in the <em>outbuf</em> character set, we emit messages similar to the ones Sybase emits when it fails such a conversion. The message varies depending on the direction of the data. On a read error, we emit Msg 2403, Severity 16 (EX_INFO): "WARNING! Some character(s) could not be converted into client's character set. Unconverted bytes were changed to question marks ('?')." On a write error we emit Msg 2402, Severity 16 (EX_USER): "Error converting client characters into server's character set. Some character(s) could not be converted." and return an error code. Client libraries relying on this routine should reflect an error back to the appliction.<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000044">Todo:</a></b></dt><dd>Check for variable multibyte non-UTF-8 input character set. <p>
Use more robust error message generation. <p>
For reads, cope with  encodings that don't have the equivalent of an ASCII '?'. <p>
Support alternative to '?' for the replacement character. </dd></dl>
    </td>
  </tr>
</table>
<a name="a10" doxytag="tds/iconv.c::tds_iconv_fread"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> size_t tds_iconv_fread </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">iconv_t&nbsp;</td>
          <td class="mdname" nowrap> <em>cd</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>FILE *&nbsp;</td>
          <td class="mdname" nowrap> <em>stream</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>field_len</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>term_len</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>outbuf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>outbytesleft</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read a data file, passing the data through <a class="el" href="a00279.html#a2">iconv()</a>.
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Count of bytes either not read, or read but not converted. Returns zero on success. </dd></dl>
    </td>
  </tr>
</table>
<a name="a0" doxytag="replacements/iconv.c::tds_rep_iconv_open"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> iconv_t tds_rep_iconv_open </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>tocode</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>fromcode</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inputs are FreeTDS canonical names, no other.
<p>
No alias list is consulted.     </td>
  </tr>
</table>
<a name="a18" doxytag="tds/iconv.c::tds_sybase_charset_name"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const char* tds_sybase_charset_name </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>charset_name</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determine the name Sybase uses for a character set, given a canonical iconv name.
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Sybase name, or NULL if lookup failed. </dd></dl>
<dl compact><dt><b>Remarks:</b></dt><dd>Returned name can be sent to Sybase a server. </dd></dl>
    </td>
  </tr>
</table>
<hr><address style="align: right;"><small>Generated on Sun Jun 13 18:55:27 2004 for FreeTDS API by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3 </small></address>
</body>
</html>
